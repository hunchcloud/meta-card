{"version":3,"sources":["../src/hunch-observer.ts","../src/meta-proxy.ts","../src/meta-card.ts"],"names":[],"mappings":";AAsCa,aAAA,OAAA,eAAA,QAAA,aAAA,CAAA,OAAA,IA5Bb,MAAa,EAGX,cACO,KAAA,SAAW,IAAI,qBAClB,IACE,EAAQ,QAAQ,IACV,GAAA,EAAM,eAAgB,CACT,EAAM,OACd,WAIb,CACE,WAAY,sBAKlB,QAAQ,GACD,KAAA,SAAS,QAAQ,GAGxB,UAAU,GACH,KAAA,SAAS,UAAU,IAxB5B,QAAA,cAAA,EA4Ba,QAAA,cAAgB,IAAI;;ACpCpB,aAAA,OAAA,eAAA,QAAA,aAAA,CAAA,OAAA,IAFb,MAAM,EAAc,OAAQ,YAAc,mCAE7B,QAAA,UAAY,OAAA,eACV,SAAS,OAAW,MAAQ;;ACiI3C,aAAA,OAAA,eAAA,QAAA,aAAA,CAAA,OAAA,IApIA,MAAA,EAAA,QAAA,oBACA,EAAA,QAAA,gBAEM,EAAW,SAAS,cAAc,YACxC,EAAS,UAAY,89BAiErB,MAAM,UAAiB,YASrB,cACE,QAHF,KAAA,QAAkB,EAIV,MAAA,EAAS,KAAK,aAAa,CAAE,KAAM,SACzC,EAAO,YAAY,EAAS,QAAQ,WAAU,IAEzC,KAAA,MAAQ,EAAO,cAAc,KAC7B,KAAA,KAAO,EAAO,cAAc,QAC5B,KAAA,OAAS,EAAO,cAAc,UAC9B,KAAA,aAAe,EAAO,cAAc,gBACpC,KAAA,MAAQ,EAAO,cAAc,SAC7B,KAAA,KAAO,EAAO,cAAc,QAGxB,gCACF,MAAA,CAAC,QAGV,yBAAyB,EAAW,EAAgB,GAC9C,IAAW,GAAU,KAAK,QACvB,KAAA,SAIT,oBACE,EAAA,cAAc,QAAQ,MAGxB,OACO,KAAA,QAAS,EACT,KAAA,SAGP,YAAY,GACJ,MAAA,EAAM,IAAI,IAAI,GACb,SAAG,EAAI,OAAwB,MAAjB,EAAI,SAAmB,GAAK,EAAI,WAGjD,eACE,MAAA,EAAO,KAAK,aAAa,QAC3B,GAAA,EAAM,CACH,KAAA,MAAM,KAAO,EACZ,MAAA,MAAE,EAAF,MAAS,EAAT,YAAgB,EAAhB,KAA6B,SAAe,EAAA,UAAU,GACvD,KAAA,KAAK,IAAM,EACX,KAAA,OAAO,UAAY,EACnB,KAAA,aAAa,UAAY,EAC1B,IACG,KAAA,MAAM,IAAM,EACZ,KAAA,MAAM,QAAS,GAEjB,KAAA,KAAK,UAAY,KAAK,YAAY,KAK7C,eAAe,OAAO,YAAa","file":"meta-card.44baa63f.js","sourceRoot":"../example","sourcesContent":["/**\n * An `IntersectionObserver` wrapper that calls `element.load` function when an\n * observed element became visible.\n *\n * Taken from https://github.com/hunchcloud/elements\n */\nexport interface ObservableElement extends HTMLElement {\n  load: () => void;\n}\n\nexport class HunchObserver {\n  observer: IntersectionObserver;\n\n  constructor() {\n    this.observer = new IntersectionObserver(\n      entries => {\n        entries.forEach(entry => {\n          if (entry.isIntersecting) {\n            const target = entry.target as ObservableElement;\n            target.load();\n          }\n        });\n      },\n      {\n        rootMargin: \"0px 0px 120px 0px\"\n      }\n    );\n  }\n\n  observe(el: ObservableElement) {\n    this.observer.observe(el);\n  }\n\n  unobserve(el: ObservableElement) {\n    this.observer.unobserve(el);\n  }\n}\n\nexport const hunchObserver = new HunchObserver();\n","const PROXY = (<any>window).META_PROXY || \"https://meta-proxy.herokuapp.com\";\n\nexport const fetchMeta = async (url: string) =>\n  await (await fetch(`${PROXY}?q=${url}`)).json();\n","import { hunchObserver } from \"./hunch-observer\";\nimport { fetchMeta } from \"./meta-proxy\";\n\nconst template = document.createElement(\"template\");\ntemplate.innerHTML = `\n<style>\na {\n  text-decoration: none;\n  color: inherit;\n  display: block;\n  border: 1px solid #e1e8ed;\n  border-radius: 0.75em;\n  overflow: hidden;\n}\n.img {\n  width: 100%;\n  display: block;\n}\n\n.info {\n  border-top: 1px solid #e1e8ed;\n  padding: 0.75em;\n}\n\n.title {\n  font-weight: 500;\n  margin-bottom: 0.5em;\n}\n\n.description {\n  font-size: 0.875em;\n  margin-bottom: 0.5em;\n  color: #657786;\n}\n\n.origin {\n  display: flex;\n  align-items: center;\n}\n\n.logo {\n  width: 1em;\n  height: 1em;\n  border-radius: 100%;\n  margin-right: 0.25em;\n}\n\n.url {\n  font-size: 0.75em;\n  color: #657786;\n  overflow: hidden;\n  text-overflow: ellipsis;\n  white-space: nowrap;\n}\n</style>\n\n<a target=\"_blank\">\n  <img class=\"img\" loading=\"lazy\">\n  <div class=\"info\">\n    <div class=\"title\"></div>\n    <div class=\"description\"></div>\n    <div class=\"origin\">\n      <img class=\"logo\" loading=\"lazy\">\n      <div class=\"url\"></div>\n    </div>\n  </div>\n</a>\n`;\n\nclass MetaCard extends HTMLElement {\n  $card: HTMLAnchorElement;\n  $title: HTMLDivElement;\n  $img: HTMLImageElement;\n  $description: HTMLDivElement;\n  $logo: HTMLImageElement;\n  $url: HTMLDivElement;\n  loaded: Boolean = false;\n\n  constructor() {\n    super();\n    const shadow = this.attachShadow({ mode: \"open\" });\n    shadow.appendChild(template.content.cloneNode(true));\n\n    this.$card = shadow.querySelector(`a`) as HTMLAnchorElement;\n    this.$img = shadow.querySelector(`.img`) as HTMLImageElement;\n    this.$title = shadow.querySelector(`.title`) as HTMLDivElement;\n    this.$description = shadow.querySelector(`.description`) as HTMLDivElement;\n    this.$logo = shadow.querySelector(`.logo`) as HTMLImageElement;\n    this.$url = shadow.querySelector(`.url`) as HTMLDivElement;\n  }\n\n  static get observedAttributes() {\n    return [\"href\"];\n  }\n\n  attributeChangedCallback(_: string, oldVal: string, newVal: string) {\n    if (oldVal !== newVal && this.loaded) {\n      this.render();\n    }\n  }\n\n  connectedCallback() {\n    hunchObserver.observe(this);\n  }\n\n  load() {\n    this.loaded = true;\n    this.render();\n  }\n\n  stripSchema(href: string) {\n    const url = new URL(href);\n    return `${url.host}${url.pathname === \"/\" ? \"\" : url.pathname}`;\n  }\n\n  async render() {\n    const href = this.getAttribute(\"href\");\n    if (href) {\n      this.$card.href = href;\n      const { image, title, description, logo } = await fetchMeta(href);\n      this.$img.src = image;\n      this.$title.innerText = title;\n      this.$description.innerText = description;\n      if (logo) {\n        this.$logo.src = logo;\n        this.$logo.hidden = false;\n      }\n      this.$url.innerText = this.stripSchema(href);\n    }\n  }\n}\n\ncustomElements.define(\"meta-card\", MetaCard);\n"]}