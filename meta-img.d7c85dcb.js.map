{"version":3,"sources":["../src/hunch-observer.ts","../src/meta-proxy.ts","../src/meta-img.ts"],"names":[],"mappings":";AAsCa,aAAA,OAAA,eAAA,QAAA,aAAA,CAAA,OAAA,IA5Bb,MAAa,EAGX,cACO,KAAA,SAAW,IAAI,qBAClB,IACE,EAAQ,QAAQ,IACV,GAAA,EAAM,eAAgB,CACT,EAAM,OACd,WAIb,CACE,WAAY,sBAKlB,QAAQ,GACD,KAAA,SAAS,QAAQ,GAGxB,UAAU,GACH,KAAA,SAAS,UAAU,IAxB5B,QAAA,cAAA,EA4Ba,QAAA,cAAgB,IAAI;;ACpCpB,aAAA,OAAA,eAAA,QAAA,aAAA,CAAA,OAAA,IAFb,MAAM,EAAc,OAAQ,YAAc,mCAE7B,QAAA,UAAY,OAAA,eACV,SAAS,OAAW,MAAQ;;ACwD3C,aAAA,OAAA,eAAA,QAAA,aAAA,CAAA,OAAA,IA3DA,MAAA,EAAA,QAAA,oBACA,EAAA,QAAA,gBAEM,EAAW,SAAS,cAAc,YACxC,EAAS,UAAY,uJAcrB,MAAM,UAAgB,YAIpB,cACE,QAHF,KAAA,QAAkB,EAIV,MAAA,EAAS,KAAK,aAAa,CAAE,KAAM,SACzC,EAAO,YAAY,EAAS,QAAQ,WAAU,IACzC,KAAA,KAAO,EAAO,cAAc,OAGxB,gCACF,MAAA,CAAC,QAGV,2BACM,KAAK,QACF,KAAA,SAIT,oBACE,EAAA,cAAc,QAAQ,MAGxB,OACO,KAAA,QAAS,EACT,KAAA,SAGD,eACE,MAAA,EAAO,KAAK,aAAa,QAC3B,GAAA,EAAM,CACF,MAAA,MAAE,EAAF,IAAS,SAAc,EAAA,UAAU,GAGlC,KAAA,KAAK,IAAM,GAAS,IAK/B,eAAe,OAAO,WAAY","file":"meta-img.d7c85dcb.js","sourceRoot":"../example","sourcesContent":["/**\n * An `IntersectionObserver` wrapper that calls `element.load` function when an\n * observed element became visible.\n *\n * Taken from https://github.com/hunchcloud/elements\n */\nexport interface ObservableElement extends HTMLElement {\n  load: () => void;\n}\n\nexport class HunchObserver {\n  observer: IntersectionObserver;\n\n  constructor() {\n    this.observer = new IntersectionObserver(\n      entries => {\n        entries.forEach(entry => {\n          if (entry.isIntersecting) {\n            const target = entry.target as ObservableElement;\n            target.load();\n          }\n        });\n      },\n      {\n        rootMargin: \"0px 0px 120px 0px\"\n      }\n    );\n  }\n\n  observe(el: ObservableElement) {\n    this.observer.observe(el);\n  }\n\n  unobserve(el: ObservableElement) {\n    this.observer.unobserve(el);\n  }\n}\n\nexport const hunchObserver = new HunchObserver();\n","const PROXY = (<any>window).META_PROXY || \"https://meta-proxy.herokuapp.com\";\n\nexport const fetchMeta = async (url: string) =>\n  await (await fetch(`${PROXY}?q=${url}`)).json();\n","import { hunchObserver } from \"./hunch-observer\";\nimport { fetchMeta } from \"./meta-proxy\";\n\nconst template = document.createElement(\"template\");\ntemplate.innerHTML = `\n<style>\n:host {\n  display: inline-block;\n}\nimg {\n  width: 100%;\n  height: 100%;\n  object-fit: inherit;\n}\n</style>\n<img loading=\"lazy\">\n`;\n\nclass MetaImg extends HTMLElement {\n  $img: HTMLImageElement;\n  loaded: Boolean = false;\n\n  constructor() {\n    super();\n    const shadow = this.attachShadow({ mode: \"open\" });\n    shadow.appendChild(template.content.cloneNode(true));\n    this.$img = shadow.querySelector(\"img\") as HTMLImageElement;\n  }\n\n  static get observedAttributes() {\n    return [\"href\"];\n  }\n\n  attributeChangedCallback() {\n    if (this.loaded) {\n      this.render();\n    }\n  }\n\n  connectedCallback() {\n    hunchObserver.observe(this);\n  }\n\n  load() {\n    this.loaded = true;\n    this.render();\n  }\n\n  async render() {\n    const href = this.getAttribute(\"href\");\n    if (href) {\n      const { image, url } = await fetchMeta(href);\n      // Fallback to the url if image field is null, this is useful when passing\n      // img url to <meta-img href=\"https://example.com/a.jpg\"></meta-img>.\n      this.$img.src = image || url;\n    }\n  }\n}\n\ncustomElements.define(\"meta-img\", MetaImg);\n"]}